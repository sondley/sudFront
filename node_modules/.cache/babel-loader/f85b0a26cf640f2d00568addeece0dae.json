{"ast":null,"code":"import { Component } from \"react\";\nimport PropTypes from \"prop-types\";\n\nvar _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (e) {\n  return typeof e;\n} : function (e) {\n  return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n},\n    classCallCheck = function classCallCheck(e, t) {\n  if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n},\n    createClass = function () {\n  function e(e, t) {\n    for (var n = 0; n < t.length; n++) {\n      var o = t[n];\n      o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, o.key, o);\n    }\n  }\n\n  return function (t, n, o) {\n    return n && e(t.prototype, n), o && e(t, o), t;\n  };\n}(),\n    inherits = function inherits(e, t) {\n  if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n  e.prototype = Object.create(t && t.prototype, {\n    constructor: {\n      value: e,\n      enumerable: !1,\n      writable: !0,\n      configurable: !0\n    }\n  }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);\n},\n    possibleConstructorReturn = function possibleConstructorReturn(e, t) {\n  if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n},\n    IS_BROWSER = \"object\" === (\"undefined\" == typeof window ? \"undefined\" : \"undefined\" == typeof window ? \"undefined\" : _typeof(window)),\n    DEFAULT_ELEMENT = IS_BROWSER ? document : {},\n    DEFAULT_EVENTS = [\"mousemove\", \"keydown\", \"wheel\", \"DOMMouseScroll\", \"mouseWheel\", \"mousedown\", \"touchstart\", \"touchmove\", \"MSPointerDown\", \"MSPointerMove\"],\n    IdleTimer = function (e) {\n  function t(e) {\n    classCallCheck(this, t);\n    var n = possibleConstructorReturn(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e));\n    if (n.state = {\n      idle: !1,\n      oldDate: +new Date(),\n      lastActive: +new Date(),\n      remaining: null,\n      pageX: null,\n      pageY: null\n    }, n.tId = null, n._handleEvent = function (e) {\n      var t = n.state,\n          o = t.remaining,\n          i = t.pageX,\n          r = t.pageY,\n          s = t.idle,\n          u = n.props,\n          a = u.timeout,\n          l = u.onAction,\n          p = u.debounce,\n          c = u.throttle,\n          d = u.stopOnIdle;\n\n      if (p > 0 ? n.debouncedAction(e) : c > 0 ? n.throttledAction(e) : l(e), !o) {\n        if (\"mousemove\" === e.type) {\n          if (e.pageX === i && e.pageY === r) return;\n          if (void 0 === e.pageX && void 0 === e.pageY) return;\n          if (n.getElapsedTime() < 200) return;\n        }\n\n        clearTimeout(n.tId), n.tId = null, s && !d && n.toggleIdleState(e), n.setState({\n          lastActive: +new Date(),\n          pageX: e.pageX,\n          pageY: e.pageY\n        }), s && d || (n.tId = setTimeout(n.toggleIdleState, a));\n      }\n    }, e.debounce > 0 && e.throttle > 0) throw new Error(\"onAction can either be throttled or debounced (not both)\");\n    return e.debounce > 0 && (n.debouncedAction = debounced(e.onAction, e.debounce)), e.throttle > 0 && (n.throttledAction = throttled(e.onAction, e.throttle)), e.startOnMount || (n.state.idle = !0), n.toggleIdleState = n._toggleIdleState.bind(n), n.reset = n._reset.bind(n), n.pause = n._pause.bind(n), n.resume = n._resume.bind(n), n.getRemainingTime = n._getRemainingTime.bind(n), n.getElapsedTime = n._getElapsedTime.bind(n), n.getLastActiveTime = n._getLastActiveTime.bind(n), n.isIdle = n._isIdle.bind(n), n;\n  }\n\n  return inherits(t, Component), createClass(t, [{\n    key: \"componentWillMount\",\n    value: function value() {\n      this._bindEvents();\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function value() {\n      this.props.startOnMount && this.reset();\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function value() {\n      clearTimeout(this.tId), this._unbindEvents();\n    }\n  }, {\n    key: \"render\",\n    value: function value() {\n      return this.props.children || null;\n    }\n  }, {\n    key: \"_bindEvents\",\n    value: function value() {\n      var e = this;\n\n      if (IS_BROWSER) {\n        var t = this.state.eventsBound,\n            n = this.props,\n            o = n.element,\n            i = n.events,\n            r = n.passive,\n            s = n.capture;\n        t || (i.forEach(function (t) {\n          o.addEventListener(t, e._handleEvent, {\n            capture: s,\n            passive: r\n          });\n        }), this.setState({\n          eventsBound: !0\n        }));\n      }\n    }\n  }, {\n    key: \"_unbindEvents\",\n    value: function value() {\n      var e = this;\n\n      if (IS_BROWSER) {\n        var t = this.props,\n            n = t.element,\n            o = t.events,\n            i = t.passive,\n            r = t.capture;\n        this.state.eventsBound && (o.forEach(function (t) {\n          n.removeEventListener(t, e._handleEvent, {\n            capture: r,\n            passive: i\n          });\n        }), this.setState({\n          eventsBound: !1\n        }));\n      }\n    }\n  }, {\n    key: \"_toggleIdleState\",\n    value: function value(e) {\n      var t = this,\n          n = this.state.idle,\n          o = this.props,\n          i = o.onActive,\n          r = o.onIdle,\n          s = o.stopOnIdle;\n      this.setState({\n        idle: !n\n      }, function () {\n        n ? s || (t._bindEvents(), i(e)) : (s && (clearTimeout(t.tId), t.tId = null, t._unbindEvents()), r(e));\n      });\n    }\n  }, {\n    key: \"_reset\",\n    value: function value() {\n      clearTimeout(this.tId), this.tId = null, this._bindEvents(), this.setState({\n        idle: !1,\n        oldDate: +new Date(),\n        lastActive: this.state.oldDate,\n        remaining: null\n      });\n      var e = this.props.timeout;\n      this.tId = setTimeout(this.toggleIdleState, e);\n    }\n  }, {\n    key: \"_pause\",\n    value: function value() {\n      null === this.state.remaining && (this._unbindEvents(), clearTimeout(this.tId), this.tId = null, this.setState({\n        remaining: this.getRemainingTime()\n      }));\n    }\n  }, {\n    key: \"_resume\",\n    value: function value() {\n      var e = this.state,\n          t = e.remaining,\n          n = e.idle;\n      null !== t && (this._bindEvents(), n || (this.setState({\n        remaining: null\n      }), this.tId = setTimeout(this.toggleIdleState, t)));\n    }\n  }, {\n    key: \"_getRemainingTime\",\n    value: function value() {\n      var e = this.state,\n          t = e.remaining,\n          n = e.idle,\n          o = e.lastActive;\n      if (n) return 0;\n      if (null !== t) return t;\n      var i = this.props.timeout - (+new Date() - o);\n      return i < 0 && (i = 0), i;\n    }\n  }, {\n    key: \"_getElapsedTime\",\n    value: function value() {\n      var e = this.state.oldDate;\n      return +new Date() - e;\n    }\n  }, {\n    key: \"_getLastActiveTime\",\n    value: function value() {\n      return this.state.lastActive;\n    }\n  }, {\n    key: \"_isIdle\",\n    value: function value() {\n      return this.state.idle;\n    }\n  }]), t;\n}();\n\nfunction debounced(e, t) {\n  var n = void 0;\n  return function () {\n    for (var o = arguments.length, i = Array(o), r = 0; r < o; r++) {\n      i[r] = arguments[r];\n    }\n\n    n && clearTimeout(n), n = setTimeout(function () {\n      e.apply(void 0, i), n = null;\n    }, t);\n  };\n}\n\nfunction throttled(e, t) {\n  var n = 0;\n  return function () {\n    var o = new Date().getTime();\n    if (!(o - n < t)) return n = o, e.apply(void 0, arguments);\n  };\n}\n\nIdleTimer.propTypes = {\n  timeout: PropTypes.number,\n  events: PropTypes.arrayOf(PropTypes.string),\n  onIdle: PropTypes.func,\n  onActive: PropTypes.func,\n  onAction: PropTypes.func,\n  debounce: PropTypes.number,\n  throttle: PropTypes.number,\n  element: PropTypes.oneOfType([PropTypes.object, PropTypes.element]),\n  startOnMount: PropTypes.bool,\n  stopOnIdle: PropTypes.bool,\n  passive: PropTypes.bool,\n  capture: PropTypes.bool\n}, IdleTimer.defaultProps = {\n  timeout: 12e5,\n  element: DEFAULT_ELEMENT,\n  events: DEFAULT_EVENTS,\n  onIdle: function onIdle() {},\n  onActive: function onActive() {},\n  onAction: function onAction() {},\n  debounce: 0,\n  throttle: 0,\n  startOnMount: !0,\n  stopOnIdle: !1,\n  capture: !0,\n  passive: !0\n};\nexport default IdleTimer;","map":null,"metadata":{},"sourceType":"module"}